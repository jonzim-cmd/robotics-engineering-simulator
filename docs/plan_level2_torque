# Implementierungsplan: Level 2 - Getriebe-Simulation (The Cockpit)

Dieser Plan beschreibt die vollstÃ¤ndige Neuentwicklung der Simulations-Phase in Level 2. Ziel ist ein interaktives "Tuning-Cockpit", das physikalische ZusammenhÃ¤nge visuell erlebbar macht ("Show, don't tell"), anstatt nur Schieberegler zu bieten.

## 1. Zielsetzung & Didaktik
*   **Lernziel:** SchÃ¼ler (10. Klasse) sollen intuitiv verstehen, dass ein Getriebe Kraft (Drehmoment) gegen Geschwindigkeit tauscht.
*   **Die Herausforderung:** Eine 20Â°-Rampe muss Ã¼berwunden werden.
    *   Zu wenig Ãœbersetzung = Motor wÃ¼rgt ab (zu wenig Kraft).
    *   Zu viel Ãœbersetzung = Rover kriecht (zu langsam fÃ¼r den Warenfluss).
    *   Zu wenig Gas = Ebenfalls zu langsam.
*   **Methode:** Visuelles Feedback durch rotierende ZahnrÃ¤der und Live-Telemetrie statt nackter Zahlen.

## 2. UX Flow
1.  **Start:** Nach der Smartphone-Recherche Ã¶ffnet sich das `Level2TuningCockpit`.
2.  **Interaktion:**
    *   Spieler bedient einen "Schubhebel" (Motordrehzahl) und einen "Getriebe-Wahlhebel" (Ãœbersetzung).
    *   **Visuelles Feedback:** Zwei ZahnrÃ¤der drehen sich live. Die GrÃ¶ÃŸe des abtreibenden Zahnrads Ã¤ndert sich mit der Ãœbersetzung.
    *   **Telemetrie:** Anzeigen fÃ¼r "Kraft am Rad" und "Geschwindigkeit" reagieren sofort.
3.  **Aktion:** Klick auf "TESTFAHRT STARTEN" (Kostet 5 Credits).
4.  **Ergebnis:**
    *   Simulation lÃ¤uft intern.
    *   Visuelle RÃ¼ckmeldung (Erfolgs-Pop-up oder Fehler-Analyse).
    *   Bei 0 Credits: Die "Chefin" erscheint (Game Over / Reset Loop).

## 3. Technische Spezifikation: Das Cockpit UI

Erstelle eine neue Komponente `src/components/ui/Level2TuningCockpit.tsx`.

### 3.1. Visualisierung (Die ZahnrÃ¤der)
Statt statischer Icons nutzen wir animierte SVGs.
*   **Motor-Ritzel (Links):**
    *   Feste GrÃ¶ÃŸe (klein).
    *   Dreht sich basierend auf `motorSpeed`.
    *   Farbe: Technisches Dunkelgrau/Metall.
*   **Antriebs-Rad (Rechts):**
    *   **Variable GrÃ¶ÃŸe:** Skaliert mit dem gewÃ¤hlten `gearRatio`.
        *   Kleine Ãœbersetzung -> Kleines Rad (schnell).
        *   GroÃŸe Ãœbersetzung -> GroÃŸes Rad (langsam, krÃ¤ftig).
    *   Dreht sich basierend auf `motorSpeed / gearRatio`.
    *   Verbindung: Angedeutete Kette oder direkter Kontakt.

### 3.2. Controls (Industrial Design)
*   **Getriebe-Hebel (Horizontal):**
    *   Label: "GETRIEBE-RATIO"
    *   Links: "SPEED" (Symbol: Hase/Blitz)
    *   Rechts: "POWER" (Symbol: Gewicht/Berg)
    *   Wertebereich intern: `3.0` bis `20.0`.
*   **Motor-Throttle (Vertikal):**
    *   Label: "MOTOR RPM"
    *   Unten: 0%
    *   Oben: 100% (Warnbereich oben rot markieren).

### 3.3. Live-Telemetrie (Gauges)
Verwende Balkenanzeigen mit Farbverlauf (GrÃ¼n -> Gelb -> Rot oder umgekehrt, je nach Kontext).
1.  **Drehmoment am Rad (Nm):**
    *   Zeigt an, wie viel Kraft aktuell anliegt.
    *   Markiere den "BenÃ¶tigten Bereich" (Threshold) visuell (z.B. durch einen Strich im Balken). Ist der Balken darunter -> Rot.
2.  **Geschwindigkeit (km/h):**
    *   Zeigt die theoretische Endgeschwindigkeit an.
    *   Markiere den "Minimum Bereich". Ist der Balken darunter -> Gelb/Orange.

## 4. Physik-Engine (Hard Mode)

Wir nutzen ein "Goldilocks"-Modell (genau die richtige Zone finden). Die Physik muss strenger sein als bisher.

Implementiere/Aktualisiere diese Logik in `src/lib/physicsEngine.ts`:

### 4.1. Konstanten & Setup
```typescript
const VEHICLE_MASS = 200;     // kg
const GRAVITY = 9.81;         // m/sÂ²
const RAMP_ANGLE = 20;        // Grad
const WHEEL_RADIUS = 0.25;    // Meter

// Das Puzzle-Design (Die "Sweet Spot" Logik):
// Ziel: Ãœbersetzung muss zwischen ~9.0 und ~14.0 liegen.
// Ziel: Motordrehzahl muss > 70% sein.

const MAX_MOTOR_TORQUE = 20;  // Nm (Reduziert von 50!)
const MAX_MOTOR_SPEED = 90;   // rad/s (Reduziert von 300!)

// Physik-Berechnung:
// 1. Hangabtriebskraft: F_hang = m * g * sin(20Â°) â‰ˆ 671 N
// 2. BenÃ¶tigtes Drehmoment am Rad: M_req = F_hang * r â‰ˆ 167.7 Nm
// 3. Notwendige Ãœbersetzung: i_min = M_req / M_motor = 167.7 / 20 â‰ˆ 8.4
```

### 4.2. Simulations-Logik
Eingabe: `gearRatio` (3-20), `motorSpeedFactor` (0-1).

1.  **Kraft-Check (Stalling):**
    *   `torqueAtWheel = MAX_MOTOR_TORQUE * gearRatio`
    *   `requiredTorque = 168` (ca.)
    *   **Logik:** Wenn `torqueAtWheel < requiredTorque` -> **FAIL: STALLED** ("Bleibt am Hang stehen").

2.  **Geschwindigkeits-Check (Too Slow):**
    *   `wheelRPM = (motorSpeedFactor * MAX_MOTOR_SPEED) / gearRatio`
    *   `velocity = wheelRPM * WHEEL_RADIUS` (m/s)
    *   `minVelocity = 1.5` m/s (ca. 5.4 km/h)
    *   **Logik:** Wenn `velocity < minVelocity` -> **FAIL: TOO SLOW** ("Schleicht den Berg hoch").

3.  **Erfolg:**
    *   Wenn weder Stalled noch Too Slow -> **SUCCESS**.

## 5. Game Loop & Credit System

### 5.1. Der "Testfahrt"-Button
*   Text: "TESTFAHRT STARTEN [-5 Credits]"
*   Status: Deaktiviert, wenn Simulation lÃ¤uft.

### 5.2. Credit Logik
*   Start-Credits: 15
*   Kosten pro Versuch: 5
*   Anzeige: Digitaler Counter (z.B. oben rechts im Panel).

### 5.3. Das "Chefin"-Modal (Fail State)
Triggert, wenn Credits < 5 und Spieler drÃ¼ckt Start.
*   **Inhalt:**
    *   Avatar/Icon: ðŸ˜  (Bazlin).
    *   Headline: "Budget Ã¼berschritten!"
    *   Text: "Unit-7 steht immer noch? Wir verbrennen hier Geld! Ich setze Ihr Budget zurÃ¼ck, aber denken Sie diesmal erst nach, bevor Sie drÃ¼cken!"
*   **Aktion:**
    *   Button: "Verstanden..."
    *   Reset Credits auf 15.
    *   SchlieÃŸe Modal.

## 6. UI Feedback (Nach dem Test)
Verwende `framer-motion` fÃ¼r eine "Result Notification", die Ã¼ber dem Cockpit einblendet.

*   **Szenario 1 (Stall):** Roter Alarm. "ANTRIEB ÃœBERLASTET. Drehmoment reicht nicht fÃ¼r 20Â° Steigung."
*   **Szenario 2 (Slow):** Gelber Warnhinweis. "TIMEOUT. Fahrzeug erreicht Ziel nicht rechtzeitig. Warenfluss stockt."
*   **Szenario 3 (Success):** GrÃ¼nes Erfolgs-Banner. "OPTIMALER BETRIEB. Steigung bewÃ¤ltigt, Zeitplan eingehalten."

## 7. Zusammenfassung der Aufgaben fÃ¼r die KI
1.  Aktualisiere `src/lib/physicsEngine.ts` mit den neuen, strengen Konstanten.
2.  Erstelle `src/components/ui/Level2TuningCockpit.tsx` mit:
    *   SVG-Zahnrad-Animation (GrÃ¶ÃŸe & Drehzahl gekoppelt an State).
    *   Industrial-Style Slidern.
    *   Live-Balken fÃ¼r Torque/Speed mit Markierungen fÃ¼r Soll-Werte.
3.  Integriere das Credit-System und das Boss-Modal.
4.  Baue die Simulations-Logik basierend auf den neuen Konstanten ein.